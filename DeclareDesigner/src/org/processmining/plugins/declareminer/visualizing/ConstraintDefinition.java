/* Generated by Together */

package org.processmining.plugins.declareminer.visualizing;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

public class ConstraintDefinition extends ConstraintTemplate {

	/**
	 * @clientCardinality 0..*
	 * @supplierCardinality 1
	 */
	private AssignmentModel assignmentModel;

	/**
	 * @clientCardinality 0..*
	 * @supplierCardinality 1
	 */

	private Condition condition;

	private boolean mandatory;
	
	private boolean visible;

//	public void setVisible(boolean visible) {
//		this.visible = visible;
//	}
//
//	public boolean isVisible() {
//		return visible;
//	}

	private ConstraintLevel level;

	private final HashMap<Parameter, HashSet<ActivityDefinition>> realParameters = new HashMap<Parameter, HashSet<ActivityDefinition>>();

	/**
	 * LTLConstraintDefinition call this constructor to create a constraint in
	 * the model based on a template
	 * 
	 * @param definition
	 *            ConstraintDefiniton -> copy all data from another definiton
	 */
	public ConstraintDefinition(final ConstraintDefinition definition) {
		this(definition.getId(), definition.assignmentModel, definition);
		setMandatory(definition.getMandatory());
		condition = definition.condition;
		level = definition.level;
		for (final Map.Entry<Parameter, HashSet<ActivityDefinition>> entry : definition.realParameters.entrySet()) {
			final Collection<ActivityDefinition> real = realParameters.get(entry.getKey());
			real.addAll(entry.getValue());
		}
	}

	public ConstraintDefinition(final int anId, final AssignmentModel anAssignmentModel,
			final ConstraintTemplate anTemplate) {
		super(anId, anTemplate);
		setMandatory(true);

		assignmentModel = anAssignmentModel;
		condition = new Condition();
		level = null;
		for (final Parameter p : parameters) {
			realParameters.put(p, new HashSet<ActivityDefinition>());
		}
	}

	public boolean addBranch(final Parameter p, final ActivityDefinition real) {
		return realParameters.get(p).add(real);
	}

	/**
	 * branchesCount
	 * 
	 * @return int
	 */
	public int branchesCount(final Parameter p) {
		return realParameters.get(p).size();
	}

	public void cleanAllParameterBranches() {
		for (final Map.Entry<Parameter, HashSet<ActivityDefinition>> entry : realParameters.entrySet()) {
			realParameters.get(entry.getKey()).clear();
		}
	}

	public void clearBranches(final Parameter p) {
		realParameters.get(p).clear();
	}

	@Override
	public Object clone() {
		final ConstraintDefinition clone = new ConstraintDefinition(this);
		return clone;
	}

	/**
	 * deleteBranch
	 * 
	 * @param activityDefinition
	 *            AbstractEvent
	 * @return boolean
	 */
	public void deleteBranch(final Parameter p, final ActivityDefinition real) {
		realParameters.get(p).remove(real);
	}

	/**
	 * depensOn
	 * 
	 * @param activityDefinition
	 *            ActivityDefinition
	 * @return boolean
	 */
	public boolean dependsOn(final ActivityDefinition activityDefinition) {
		for (final Parameter p : parameters) {
			if (hasBranch(p, activityDefinition)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * equals
	 * 
	 * @param anObject
	 *            Object
	 * @return boolean
	 */
	@Override
	public boolean equals(final Object anObject) {
		boolean result = false;
		if (anObject != null) {
			if (anObject instanceof ConstraintDefinition) {
				final ConstraintDefinition constraint = (ConstraintDefinition) anObject;
				result = constraint.getId() == getId();
			}
		}
		return result;
	}

	/**
	 * getBranch
	 * 
	 * @param activityDefinition
	 *            ActivityDefinition
	 * @return boolean
	 */

	/*
	 * public ActivityDefinition getBranch(Parameter p, ActivityDefinition real)
	 * { boolean found = false; ActivityDefinition branch = null;
	 * Iterator<ActivityDefinition> i = this.getBranches(p).iterator(); while (
	 * (!found) && i.hasNext()) { branch = i.next(); if (branch.equals(real)){
	 * return branch; } } return null; }
	 */

	public Collection<ActivityDefinition> getBranches(final Parameter p) {
		return realParameters.get(p);
	}

	public String getCaption() {
		return getName() + ": " + parameters() + "";
	}

	/**
	 * @return Condition
	 */
	public Condition getCondition() {
		return condition;
	}

	@Override
	public String getDescription() {
		return replaceParameters(super.getDescription());
	}

	public ActivityDefinition getFirstBranch(final Parameter p) {
		final Iterator<ActivityDefinition> branches = getBranches(p).iterator();
		if (branches.hasNext()) {
			return branches.next();
		}
		return null;
	}

	/**
	 * @return ConstraintLevel
	 */
	public ConstraintLevel getLevel() {
		return level;
	}

	/**
	 * @return boolean
	 */
	public boolean getMandatory() {
		return mandatory;
	}

	/**
	 * branchAt
	 * 
	 * @param index
	 *            int
	 * @return AbstractEvent
	 */
	/*
	 * public ActivityDefinition branchAt(Parameter p, int index) { if (index >
	 * branchesCount(p)) { return null; } return getBranches(p).get(index); }
	 */

	@Override
	public String getStateMessage(final State state) {
		return replaceParameters(super.getStateMessage(state));
	}

	public boolean hasBranch(final Parameter p, final ActivityDefinition real) {
		final Iterator<ActivityDefinition> iterator = getBranches(p).iterator();
		boolean found = false;
		while (iterator.hasNext() && !found) {
			found = iterator.next().equals(real);
		}
		return found;
	}

	/**
	 * Returns the index of a branch with the job descritpion.
	 * 
	 * @param activityDefinition
	 *            ActivityDefinition
	 * @return The index of a branch with the job descritpion. -1 if the branch
	 *         with the job decsription has not been found
	 */
	public int isBranchAt(final Parameter p, final ActivityDefinition real) {
		int i = 0;
		final Iterator<ActivityDefinition> iterator = getBranches(p).iterator();
		boolean found = false;
		while (iterator.hasNext() && !found) {
			final ActivityDefinition branch = iterator.next();
			found = branch.equals(real);
			i++;
		}
		return found ? i - 1 : -1;
	}

	/**
	 * isBranched
	 * 
	 * @return boolean
	 */
	public boolean isBranched(final Parameter p) {
		final boolean result = p.isBranchable() ? !realParameters.get(p).isEmpty() : false;
		return result;
	}

	/**
	 * @param level
	 *            ConstraintLevel
	 */
	public void setLevel(final ConstraintLevel level) {
		this.level = level;
		mandatory = level == null;
	}

	/**
	 * @param mandatory
	 *            boolean
	 */
	public void setMandatory(final boolean mandatory) {
		this.mandatory = mandatory;
		if (mandatory) {
			level = null;
		}
	}

	/**
	 * toString
	 * 
	 * @return String
	 */
	@Override
	public String toString() {
		return condition.getText();
	}

	/**
	 * @param parameter
	 *            Parameter
	 * @return String
	 */
	private String branches(final Parameter parameter) {
		String result = "";
		for (final ActivityDefinition branch : getBranches(parameter)) {
			if (!result.equals("")) {
				result += ", ";
			}
			result += branch.getName();
		}
		return "[" + result + "]";
	}

	private String parameters() {
		String result = "";
		for (final Parameter parameter : parameters) {
			if (!result.equals("")) {
				result += ", ";
			}
			result += branches(parameter);

		}
		return result;
	}

	private String replaceParameters(final String s) {
		String msg = new String(s);
		for (final Parameter p : parameters) {
			String real = "";
			for (final ActivityDefinition branch : getBranches(p)) {
				if (!real.equals("")) {
					real += " or ";
				}
				real += "<b>" + branch.getName() + "</b>";
			}
			final String quote = msg.contains("&quot;") ? "&quot;" : "\"";
			msg = msg.replaceAll(quote + p.getName() + quote, real);
		}
		return msg;
	}

	protected AssignmentModel getAssignmentModel() {
		return assignmentModel;
	}

	protected void setAssignmentModel(final AssignmentModel assignmentModel) {
		this.assignmentModel = assignmentModel;
	}
}
